https://github.com/khan4019/angular-interview-questions/tree/master
https://www.code-sample.com/2016/06/angular-2-interview-questions-and.html
https://www.tutorialspoint.com/angular2/angular2_interview_questions.htm
https://github.com/Yonet/Angular-Interview-Questions
https://www.codeproject.com/Articles/1071285/Latest-TypeScript-Interview-Questions-for-Beginner
https://www.codeproject.com/Articles/1169073/Angular-Interview-Questions
https://codecraft.tv/courses/angular/unit-testing/overview/
===================================================================================================================
What are the differences between AngularJS (angular 1.x) and Angular (Angular 2.x and beyond)?
https://medium.com/@angularminds/comparison-between-angular-1-vs-angular-2-vs-angular-4-62fe79c379e3
10 major differences are
1-AngularJS architecture is based on MVC . Angular 2 architecture is based on service/controller 
	Upgrade of the version from 2.0 to 4.0 has reduced it’s bundled file size by 60%.
2-Angular JS use JavaScript. Angular v2.0 angular team used typescript
 controller concept which was present in Angular v1.0 is eliminated in Angular v2.0. Angular v2.0 has changed to component based UI.
 Angular 2.0 has made it possible to accomplish the native applications for a mobile platform like React Native. 
 Angular 2.0 provides application layer and the rendering layer. 
 view engine introduced Angular 4, which decreased the size of the generated code using the Ahead of Time (AOT) manner.
  Angular Ahead-of-Time (AOT) compiler converts your Angular HTML and TypeScript code into efficient JavaScript code during the build phase before the browser downloads and runs that code.
===================================================================================================================
What is a component? Why would you use it?
Components are the most basic building block of an UI in an Angular application. 
An Angular application is a tree of Angular components. 
Angular components are a subset of directives. 
Unlike directives, components always have a template and only one component can be instantiated per an element in a template.
Components are basically classes that interact with the .html file of the component, which gets displayed on the browser.
it divides angular into different smaller parts
one or more components forms one module which can be displayed as html in angular.
it is used to split the specific functionality to smaller parts.
app component which is created by default will always remain the parent and the next components created will form the child component.
A component must belong to an NgModule in order for it to be usable by another component or application
===================================================================================================================
What is the minimum definition of a component?
The absolute minimal configuration for a @Component in angular is a template. 
Both template properties are set to optional because you have to define either template or templateUrl.
When you don't define them, you will get an exception like this;
No template specified for component 'ComponentName'
A selector property is not required, as you can also use your components in a route.
===================================================================================================================
What is a module, and what does it contain?
a module is a mechanism to group components, directives, pipes and services that are related, in such a way that can be combined with other modules to create an application
Modules allow you to manage your components to bring modularity to your app.
===================================================================================================================
What is a service, and when will you use it?
Angular services are singleton objects which get instantiated only once during the lifetime of an application.
They contain methods that maintain data throughout the life of an application.
The main objective of a service is to organize and share business logic, models, or data and functions with different components of an Angular application.
An Angular service is a stateless object and provides some very useful functions.
These functions can be invoked from any component of Angular, like Controllers, Directives, etc
===================================================================================================================
What is a promise? Explain it laymen's terms.
A promise represents the eventual result of an asynchronous operation.
that basically means is that you wont be able to access the result of that async operation immediately.you have to wait until the promise has been settled.
day to day example: when you were younger and told your mom "I promise to take out the trash". That meant you will fulfill your promise and throw out the trash some time later in the day. That could be in a couple of minutes or a couple of hours.
var promise = new Promise(function(resolve, reject) {
  // do a thing, possibly async, then…
  if (/* everything turned out fine */) {
    resolve("Stuff worked!");
  }
  else {
    reject(Error("It broke"));
  }
});
promise.then(function(result) {
  console.log("Promise worked");
}, function(err) {
  console.log("Something broke");
});
The promise constructor takes in one argument:  callback function with two parameters resolve and reject.
there are 3 states to a promise:

pending: awaiting promise response
resolve : promise has successfully returned
reject: failure occurred

complete example
called function
const loadImage = url => {
  return new Promise(function(resolve, reject) {

    //Open a new XHR
    var request = new XMLHttpRequest();
    request.open('GET', url);

    // When the request loads, check whether it was successful
    request.onload = function() {
      if (request.status === 200) {
        // If successful, resolve the promise
        resolve(request.response);
      } else {
        // Otherwise, reject the promise
        reject(Error('An error occurred while loading image. error code:' + request.statusText));
      }
    };
    request.send();
  });
};
caller function
const embedImage = url => {
  loadImage(url).then(function(result) {
      const img = new Image();
      var imageURL = window.URL.createObjectURL(result);
      img.src = imageURL;
      document.querySelector('body').appendChild(img);
    },
    function(err) {
      console.log(err);
    });
}
===================================================================================================================
What are the lifecycle hooks for components and directives?
ngOnChanges()-when Angular (re)sets data-bound input properties. receives a SimpleChanges object of current and previous property values
ngOnInit()-Initialize the directive/component after Angular first displays the data-bound properties
ngDoCheck()-Detect and act upon changes that Angular can't or won't detect on its own.
ngAfterContentInit()-after Angular projects external content into the component's view
ngAfterContentChecked()-after Angular checks the content projected into the directive/component.
ngAfterViewInit()-after Angular initializes the component's views and child views / the view that a directive is in.
ngAfterViewChecked()-after Angular checks the component's views 
ngOnDestroy()- before Angular destroys the directive/component. 
		Unsubscribe Observables and detach event handlers to avoid memory leaks.
===================================================================================================================
What are pipes? Give me an example.
pipe is a kind of transformer.
A pipe takes in data as input and transforms it to a desired output
example 
Async ---   <li *ngFor="let item of data | async">
currency ---
			{{ price | currency:'CAD' }}
			{{ price | currency:'USD':true }}
			{{ price | currency:'EUR':false:3.2-2 }}
date ---
{{ someDate | date:'medium' }}
{{ someDate | date:'fullDate' }}
{{ someDate | date:'yy' }}
{{ someDate | date:'Hm' }}
Json---
{{ someObject | json }}
uppercase, lowercase, percentage, slice
custom pipe
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({name: 'reverseStr'})
export class ReverseStr implements PipeTransform {
  transform(value: string): string {
    let newStr: string = "";
    for (var i = value.length - 1; i >= 0; i--) {
      newStr += value.charAt(i);
    }
    return newStr;
  }
}
===================================================================================================================
What are the differences between reactive forms and template driven forms?
Template Driven Forms Features-
Easier to use
Suitable for simple scenarios
Uses Two way data binding(using [(NgModel)] syntax)
Minimal component code
Automatic track of the form and its data(handled by Angular)
Unit testing is challenge

Reactive Forms Features-
Easier Unit testing
More flexible,So Handles any complex scenarios.
Reactive transformations can be made possible such as Adding elements dynamically
No data binding is done(Immutable data model preferred by most developers)
More component code and less HTML markup
https://blog.angular-university.io/introduction-to-angular-2-forms-template-driven-vs-model-driven/

Advantages and Disadvantages of Template Driven Forms
FormsModule is used for this purpose
keeping the template as the source of all form validation truth is something that can become pretty hard to read rather quickly.
As we add more and more validator tags to a field or when we start adding complex cross-field validations the readability of the form decreases, 
to the point where it will be harder to hand it off to a web designer.
upside of this way of handling forms is its simplicity, and it's probably more than enough to build a large range of forms.
On the downside, the form validation logic cannot be unit tested. The only way to test this logic is to run an end to end test with a browser,
for example using a headless browser like PhantomJs

Advantages and Disadvantages of Reactive Forms
ReactiveFormsModule is used for this purpose
since validation logic is written in conroller We can now unit test the form validation logic.
the main point is that the form controls and the form itself now provide an Observable-based API. You can think of observables simply as a collection of values over time.
FormGroup provides two API methods for updating form values
patchValue() This method does not need to receive values for all fields of the form, which allows for partial updates
setValue() we are passing all the values of the form. In the case of this method, values for all form fields need to be provided
		otherwise, we will get an error message saying that certain field values are missing

Are you migrating an Angular 1 application into Angular? That is the ideal scenario for using Template Driven Forms.
Or are you building a new application from scratch? Reactive forms are a good default choice because more complex validation logic is actually simpler to implement using them.
With reactive forms, we just need to write a function and plug it into the FormControl. With template driven forms, there is more to it: we need to define a directive and somehow pass it the value of the two fields.
===================================================================================================================
What is a dumb, or presentation, component? What are the benefits of using dumb components?
smart component - also know sometimes as application-level components, container components or controller components
it interacts with service and is  kind of large component, interact with service also
Presentation Components: also known sometimes as pure components or dumb components
only used for showing data template by using @input and @ Output
===================================================================================================================
How do components communicate with each other?
Passing the reference of one component to another(Input)
Communication through parent component(EventEmitter)
Communication through Service
===================================================================================================================
How would you use http to load data from server?

getCustomer() {
    return this.http.get('/someUrl').map(res => res.json());
}

let network$ = getCustomer();
let subscriber1 = network$.subscribe(...);
let subscriber2 = network$.subscribe(...);
As per Angular 5 new HttpClient, the .map(res => res.json()) part in all examples is now useless, as JSON result is now assumed by default.

complete way of getting http using cache
@Injectable()
export class DataService {
  private url:string = 'https://cors-test.appspot.com/test';

  private data: Data;
  private observable: Observable<any>;

  constructor(private http:Http) {}

  getData() {
    if(this.data) {
      // if `data` is available just return it as `Observable`
      return Observable.of(this.data); 
    } else if(this.observable) {
      // if `this.observable` is set then the request is in progress
      // return the `Observable` for the ongoing request
      return this.observable;
    } else {
      // example header (not necessary)
      let headers = new Headers();
      headers.append('Content-Type', 'application/json');
      // create the request, store the `Observable` for subsequent subscribers
      this.observable = this.http.get(this.url, {
        headers: headers
      })
      .map(response =>  {
        // when the cached data is available we don't need the `Observable` reference anymore
        this.observable = null;

        if(response.status == 400) {
          return "FAILURE";
        } else if(response.status == 200) {
          this.data = new Data(response.json());
          return this.data;
        }
        // make it shared so more than one subscriber can get the result
      })
      .share();
      return this.observable;
    }
  }
}
=================================================================================================================== 
How do you create routes?
we need to setup some imports
import {Routes, RouterModule} from "@angular/router";
mapping of URLs to Components called route configuration
const routes: Routes = [
 { path: '', component: HomeComponent },
 { path: 'search', component: SearchComponent }
];
Routes is a typescript type of Route[], an array of individual Route instances.
RouterModule.forRoot(routes) in our ngModule
We need to add a directive called router-outlet
The redirectTo property describes the path we want to redirect this user to if they navigate to this URL.
pathMatch: 'full' property for empty string so Angular knows it should be matching exactly the empty string and not partially the empty string
catch all route by using the path **

We simply add a standard href with a value of /#/
this.router.navigate(['search']);
We don’t have to pass in the # character in the parameters to the navigate function, it automatically adds them in if we are using the HashLocationStrategy.
change search route to {path: 'search/foo/moo', component: SearchComponent},
this.router.navigate(['search', 'foo', 'moo']);
routerLinkActive directive is associated with a route through a routerLink directive.
parameterized routes
const routes: Routes = [
 { path: 'blog/:id', component: BlogComponent } 
];
Non-parameterised routes take precedence over parameterised routes.
const routes: Routes = [
 { path: 'blog/:id', component: BlogComponent },
 { path: 'blog/moo', component: MooComponent }, //this is preferred over first one
];
/blog/1 how does BlogComponent know the id is 1 and therefore to show the appropriate article.
To do that we use something called an ActivatedRoute.
constructor(private route: ActivatedRoute) {
    this.route.params.subscribe( params => console.log(params) );
}
Child routes or nested routes
const routes: Routes = [
  {path: '', redirectTo: 'home', pathMatch: 'full'},
  {path: 'find', redirectTo: 'search'},
  {path: 'home', component: HomeComponent},
  {path: 'search', component: SearchComponent},
  {
    path: 'artist/:artistId',
    component: ArtistComponent,
    children: [
      {path: '', redirectTo: 'tracks'}, 
      {path: 'tracks', component: ArtistTrackListComponent}, 
      {path: 'albums', component: ArtistAlbumListComponent}, 
    ]
  },
  {path: '**', component: HomeComponent}
];
<h1>Artist</h1>
<p>
  <a [routerLink]="['./tracks']">Tracks</a> |
  <a [routerLink]="['./albums']">Albums</a>
</p>
Pre-pending with ./ clearly expresses our intent that the path is relative so lets use this syntax instead.
this.route.params.subscribe(params => console.log(params)); // Object {}
therefore we use 
this.route.parent.params.subscribe(params => console.log(params)); // Object {artistId: 12345}
--------------------------------
Routing guards
CanActivate- Checks to see if a user can visit a route.
CanActivateChild - Checks to see if a user can visit a routes children.
CanDeactivate - Checks to see if a user can exit a route.
Resolve - Performs route data retrieval before route activation.
CanLoad - Checks to see if a user can route to a module that lazy loaded.

Guards are implemented as services
import {CanActivate} from "@angular/router";
class AlwaysAuthGuard implements CanActivate {
  canActivate() {
    console.log("AlwaysAuthGuard");
    return true;
  }
}
add to providers array of @NgModule
{ path: 'artist/:artistId', component: ArtistComponent, canActivate: [OnlyLoggedInUsersGuard,AlwaysAuthGuard] }
canActivateChild - works for chil routes

whether or not a guard should accept or deny access the guard function can be passed certain arguments:
1.component: Component this is the component itself.
2.route: ActivatedRouteSnapshot — this is the future route that will be activated if the guard passes, we can use it’s params property to extract the route params.
3.state: RouterStateSnapshot — this is the future RouterState if the guard passes, we can find the URL we are trying to navigate to from the url property.
===================================================================================================================
How can you get the current state of a route?
constructor(private router:Router) { ... }

    ngOnInit() {
        let currentUrl = this.router.url; /// this will give you current url

        // your logic to know if its my home page.
    }
===================================================================================================================
How do you create two-way data binding?
<input [(ngModel)]="name" >
What this is doing behind the scenes is equivalent to:
<input [ngModel]="name" (ngModelChange)="name=$event">
===================================================================================================================
How do you load external modules?
npm install as dev/normal dependencies then load in module as imports array 
===================================================================================================================
How would you display form validation errors?
<div class="form-group" [ngClass]="displayFieldCss('email')">
    <div class="col-sm-12">
      <label for="email" class="control-label required">Email</label>
      <input type="text" id="email" class="form-control" formControlName="email">
      <app-field-error-display 
        [displayError]="isFieldValid('email')" 
        errorMsg="Please inform your email">
      </app-field-error-display>
    </div>
  </div>
  
  @Component({
  selector: 'app-validate-fields-submit-form',
  templateUrl: './validate-fields-submit-form.component.html',
  styles: []
})
export class ValidateFieldsSubmitFormComponent implements OnInit {
  form: FormGroup;

  constructor(private formBuilder: FormBuilder) {}

  ngOnInit() {
    this.form = this.formBuilder.group({
      name: [null, Validators.required],
      email: [null, [Validators.required, Validators.email]],
      address: this.formBuilder.group({
        street: [null, Validators.required],
        street2: [null],
        zipCode: [null, Validators.required],
        city: [null, Validators.required],
        state: [null, Validators.required],
        country: [null, Validators.required]
      })
    });
  }
}
===================================================================================================================
Which lifecycle hook would you use to unsubscribe an observable?
ngOnDestroy()
===================================================================================================================
How are services injected to your application?
Dependency Injection (DI) is a way to create objects that depend upon other objects. A Dependency Injection system supplies the dependent objects (called the dependencies) when it creates an instance of an object.
@Injectable()
export class HeroService {
  getHeroes() { return HEROES; }
}
inject dependency into constructor of component
constructor(heroService: HeroService) {
    this.heroes = heroService.getHeroes();
  }
  Component injectors are independent of each other and each of them creates its own instances of the component-provided services.
   when Angular creates a new instance of a component that has @Component.providers, it also creates a new child injector for that instance
   When Angular destroys one of these component instance, it also destroys the component's injector and that injector's service instances
===================================================================================================================
How would you create route parameters and access them from a component?
{ path: 'product-details/:id', component: ProductDetails }
<a *ngFor="let product of products"
  [routerLink]="['/product-details', product.id]">
  {{ product.name }}
</a>
goToProductDetails(id) {
  this.router.navigate(['/product-details', id]);
}
===================================================================================================================
Why would you use Angular instead of another framework, e.g., React?
Angular is a TypeScript-based Javascript framework
Angular relies on TypeScript. This offers more consistency in related examples and open source projects 
Angular is a framework rather than a library because it provides strong opinions as to how your application should be structured and also has more functionality out of the box.
React is described as “a JavaScript library for building user interfaces”
	not as a single-page application, 
	React is also used by Airbnb, Uber, Netflix, Twitter, Pinterest, Reddit, Udemy, Wix, Paypal, Imgur, Feedly, Stripe, Tumblr, Walmart
	React focuses on the use of Javascript ES6
	Their libraries can be paired to all kinds of packages

Building UIs is hard, because there are states everywhere data changing over time entails complexity
the status of the complete application is stored in an object tree within a single store. This helps with debugging the application, and some functionalities are easier to implement.
A big difference between React and Angular is one-way vs. two-way binding. Angular’s two-way-binding changes the model state when the UI element (e.g. a user input) is updated. React only goes one way: it updates the model first and then it renders the UI element
You can work with React or Vue by simply adding the Javascript library to the source code. This is not possible with Angular because of its use of TypeScript.
React and Vue give you more control to size an application by selecting only the things which are really necessary. They offer more flexibility to shift from an SPA to microservices using parts of a former application. Angular work best for SPA, as it is probably too bloated to be used for microservices.
===================================================================================================================
What is the difference between an observable and a promise?

A Promise handles a single event when an async operation completes or fails.
An Observable is like a Stream (in many languages) and allows to pass zero or more events where the callback is called for each event.
Observable also has the advantage over Promise to be cancelable
If the result of an HTTP request to a server or some other expensive async operation isn't needed anymore, the Subscription of an Observable allows to cancel the subscription, while a Promise will eventually call the success or failed callback even when you don't need the notification or the result it provides anymore.

Promises vs Observables

promise:
returns a single value
not cancellable
more readable code with try/catch and async/await
observable
works with multiple values over time
cancellable
supports map, filter, reduce and similar operators
use Reactive Extensions (RxJS)
an array whose items arrive asynchronously over time

Promise based approach
@Injectable()
export class WikipediaService {
  constructor(private jsonp: Jsonp) {}

  search (term: string) {
    var search = new URLSearchParams()
    search.set('action', 'opensearch');
    search.set('search', term);
    search.set('format', 'json');
    return this.jsonp
                .get('http://en.wikipedia.org/w/api.php?callback=JSONP_CALLBACK', { search })
                .toPromise()
                .then((response) => response.json()[1]);
  }
}
export class AppComponent {
  items: Array<string>;

  constructor(private wikipediaService: WikipediaService) {}

  search(term) {
    this.wikipediaService.search(term)
                         .then(items => this.items = items);
  }
}

Observable
export class App {
  items: Array<string>;
  term = new FormControl();
  constructor(private wikipediaService: WikipediaService) {
    this.term.valueChanges
              .debounceTime(400)        // wait for 400ms pause in events
              .distinctUntilChanged()   // ignore if next search term is same as previous
              .subscribe(term => this.wikipediaService.search(term).then(items => this.items = items));
  }
}

===================================================================================================================
What is the difference between a component and a directive?

Component
is also a type of directive with template,styles and logic part which is most famous type of directive among all in angular2. In this type of directive you can use other directives whether it is custom or builtin in the @component annotation like following:
@Component({
    selector: "my-app"
    directives: [custom_directive_here]
})

Attribute directives
are used to give custom behaviour or style to the existing elements by applying some functions/logics. like ngStyle is a attribute directive to give style dynamically to the elements
Structural directives
like *ngFor and *ngIf used for changes the DOM layout by adding and removing DOM elements. 
===================================================================================================================
Why would you use typescript aka benefits of typescript?
1.Class and Module Support
2.Static Type-checking
	var name: string;
	name = 2; // type error, assign a number to a string type variable
3.ES6 Feature Support
4.Clear Library API Definition
5.Build-in Support for JavaScript Packaging
6.Syntax Similarity to Our Backend Languages (Java, Scala)
7.Superset of JavaScript
===================================================================================================================
Why different life cycle hooks are needed for a component/directive?
We can use lifecycle hooks to perform complex state management, coordinate control flows and finesse asynchronous events that would normally result in unpredictable and volatile results.

===================================================================================================================
Why does angular use rxjs?
RxJS is a reactive streams library that allows you to work with asynchronous data streams. 
RxJS can be used both in the browser or in the server-side using Node.js.
In RxJS, you represent asynchronous data streams using observable sequences or also just called observables. 
Observables are very flexible and can be used using push or pull patterns.
Observables sequences allows us to use both push and pull patterns
===================================================================================================================
What is the purpose of using zone.js?
A Zone is an execution context that persists across async tasks. You can think of it as thread-local storage for JavaScript VMs.
So Angular probably just uses this for errors, stack traces, etc.,  and much more
 without zones, we don’t get any change detection, so we don’t get any of the nice UI updates that we’d expect
===================================================================================================================
What is the difference between ngOnInit() and the constructor() of a component?
read previous question 
===================================================================================================================
When will ngOnInit() be called? How would you make use of ngOnInit()?
read previous question 
after constructor and ngOnChanges 
before component is rendered 
basically used to load some initial data into component
===================================================================================================================
What are the benefits of using formBuilder?
Angular 1 has the handy ngMessages modules to help manage error messages and validation in forms
Angular has a new helper Class called FormBuilder. FormBuilder allows us to explicitly declare forms in our components. This allows us to also explicitly list each form control’s validator
@Component({
  selector: 'demo-app',
  templateUrl: 'app/app.component.html'
})
export class AppComponent {
  userForm: any;
  
  constructor(private formBuilder: FormBuilder) {
      
    this.userForm = this.formBuilder.group({
      'name': ['', Validators.required],
      'email': ['', [Validators.required, ValidationService.emailValidator]],
      'profile': ['', [Validators.required, Validators.minLength(10)]]
    });
  }
  
  saveUser() {
    if (this.userForm.dirty && this.userForm.valid) {
      alert(`Name: ${this.userForm.value.name} Email: ${this.userForm.value.email}`);
    }
  }
}

<form [formGroup]="userForm" (submit)="saveUser()">
  <label for="name">Name</label>
  <input formControlName="name" id="name" #name="ngControl" />
  <div [hidden]="name.valid">Required</div>

  <label for="email">Email</label>
  <input formControlName="email" id="email" #email="ngControl" />
  <div [hidden]="email.valid">Invalid</div>

  <label for="profile">Profile Description</label>
  <input formControlName="email" id="profile" #profile="ngControl" />
  <div [hidden]="profile.valid">Invalid</div>

  <button type="submit" [disabled]="!userForm.valid">Submit</button>
</form>
----------
export class ValidationService {
    static getValidatorErrorMessage(validatorName: string, validatorValue?: any) {
        let config = {
            'required': 'Required',
            'invalidCreditCard': 'Is invalid credit card number',
            'invalidEmailAddress': 'Invalid email address',
            'invalidPassword': 'Invalid password. Password must be at least 6 characters long, and contain a number.',
            'minlength': `Minimum length ${validatorValue.requiredLength}`
        };

        return config[validatorName];
    }

    static creditCardValidator(control) {
        // Visa, MasterCard, American Express, Diners Club, Discover, JCB
        if (control.value.match(/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/)) {
            return null;
        } else {
            return { 'invalidCreditCard': true };
        }
    }

    static emailValidator(control) {
        // RFC 2822 compliant regex
        if (control.value.match(/[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/)) {
            return null;
        } else {
            return { 'invalidEmailAddress': true };
        }
    }

    static passwordValidator(control) {
        // {6,100}           - Assert password is between 6 and 100 characters
        // (?=.*[0-9])       - Assert a string has at least one number
        if (control.value.match(/^(?=.*[0-9])[a-zA-Z0-9!@#$%^&*]{6,100}$/)) {
            return null;
        } else {
            return { 'invalidPassword': true };
        }
    }
}

===================================================================================================================
Intermediate Level
===================================================================================================================
How will you protect a route for authorized user only?
@Injectable()
export class LoggedInGuard implements CanActivate {
  constructor(private userService:UserService, private router:Router) {}

  canActivate() {
    const isLoggedIn = this.userService.isLoggedIn()
    if (!isLoggedIn) {
      this.router.navigate(['login'])
    }
    return isLoggedIn
  }
}
===================================================================================================================
What is a custom pipe and how will you use it?
answered above
by implementing pipeTransform interface and overriding transform method.
===================================================================================================================
What is a structural directive?
structural Directives are directives which change the structure of the DOM by adding or removing elements.
There are three built in structural directives, NgIf, NgFor and NgSwitch.
These directives work by using the HTML5 <ng-template> tag
<ng-template [ngIf]="!data.hide">
  <p class="card-text">
    {{ data.punchline }}
  </p>
</ng-template>
or
<p class="card-text"
   *ngIf="!data.hide">
  {{ data.punchline }}
</p>
===================================================================================================================
What is the difference between RouterModule.forRoot() vs RouterModule.forChild()? Why is it important?
forRoot creates a module that contains all the directives, the given routes, and the router service itself.
forChild creates a module that contains all the directives and the given routes, but does not include the router service. It registers the routers and uses the router service created at the root level.
This is important because location is a mutable global property. Having more than one object manipulating the location is not a good idea.
===================================================================================================================
What is the difference between a module's forRoot() and forChild() methods and why do you need it?
Call forRoot for root application module, AppModule. Calling it in any other module, particularly in a lazy loaded module
forRoot creates a module that contains all the directives, the given routes, and the router service itself.

Call forChild for child modules.
forChild creates a module that contains all the directives and the given routes, but does not include the router service.
===================================================================================================================
What's the difference between dirty, touched, and pristine on a form element?
Form State and Input State
AngularJS is constantly updating the state of both the form and the input fields.

Input fields have the following states:

$untouched The field has not been touched yet
$touched The field has been touched
$pristine The field has not been modified yet
$dirty The field has been modified
$invalid The field content is not valid
$valid The field content is valid
They are all properties of the input field, and are either true or false.

Forms have the following states:

$pristine No fields have been modified yet
$dirty One or more have been modified
$invalid The form content is not valid
$valid The form content is valid
$submitted The form is submitted
<div [hidden]="name.valid || name.pristine"
     class="alert alert-danger">
	 
State								Class if true	Class if false
The control has been visited.		ng-touched		ng-untouched
The control's value has changed.	ng-dirty		ng-pristine
The control's value is valid.		ng-valid		ng-invalid
===================================================================================================================
What is an async pipe? What kind of data can be used with async pipe?
With AsyncPipe we can use promises and observables directly in our template, without having to store the result on an intermediate property or variable.
AsyncPipe accepts as argument an observable or a promise, calls subcribe or attaches a then handler, then waits for the asynchronous result before passing it through to the caller.
The async pipe is a special kind of impure pipe that either waits for a promise to resolve to display data or subscribes to an observable to display the emitted values
async pipe with promise example
@Component({
  selector: 'async-pipe',
  template: `
 <div class="card card-block">
  <h4 class="card-title">AsyncPipe</h4>
  <p class="card-text" ngNonBindable>{{ promise }}</p>
  <p class="card-text">{{ promise | async }}</p> 
 </div>
  `
})
class AsyncPipeComponent {
  promise: Promise<string>;
  constructor() {
		this.promise = this.getPromise(); 
  }

  getPromise() {
     return new Promise((resolve, reject) => {
       setTimeout(() => resolve("Promise complete!"), 3000);
     });
  }
}
async pipe with observable example
@Component({
  selector: 'async-pipe',
  template: `
 <div class="card card-block">
  <h4 class="card-title">AsyncPipe</h4>
  <p class="card-text" ngNonBindable>{{ observable | async }}
  <p class="card-text">{{ observable | async }}</p> 
 </div>
`
})
class AsyncPipeComponent {
  observable: Observable<number>;

  constructor() {
    this.observable = this.getObservable();
  }

  getObservable() {
    return Observable
      .interval(1000)
      .take(10)
      .map((v) => v*v)
  }
}
===================================================================================================================
What is injectable? Give me some example.
Angular services are injectable and injector can inject it in any component in our angular application
To get instance of service in our component, we need to create a constructor with arguments of our service types in private scope
When we use @Injectable() decorator in service at class level then angular injector considers the service available to inject. 
A service contains methods that can be used by components
===================================================================================================================
What is a pure pipe?
I define a pure function as a function that doesn’t have an internal state. It means that all operations it performs are not affected by that state and given the same input parameters and produces the same deterministic output.

the pipe is pure it means that there’s no internal state and the pipe can be shared
Even though there are two usages in the template Angular can create only one pipe instance which can be shared between the usages.
But if a pipe is impure and has internal state the same parameters do not guarantee that same output
A good example of impure pipe is the AsyncPipe
The other two impure pipes are JsonPipe and SlicePip
===================================================================================================================
How will you create two-way data binding in Angular?
There’s one directive in Angular >= 2.x that implements two-way data binding: ngModel
<input [(ngModel)]="username">
below is same as above
<input [ngModel]="username" (ngModelChange)="username = $event">
he property binding [ngModel] takes care of updating the underlying input DOM element. The event binding (ngModelChange) notifies the outside world when there was a change in the DOM.
$event is the payload of the emitted event. In other words, ngModelChange takes care of extracting target.value from the inner $event payload, and simply emits that
===================================================================================================================
How do components communicate with each other?
three ways of implementing this
1. Passing the reference of one component to another
This solution should be used when components have dependency between them
<app-side-bar-toggle [sideBar]="sideBar"></app-side-bar-toggle>
<app-side-bar #sideBar></app-side-bar>
@Component({
  selector: 'app-side-bar-toggle',
  templateUrl: './side-bar-toggle.component.html',
  styleUrls: ['./side-bar-toggle.component.css']
})
export class SideBarToggleComponent {

  @Input() sideBar: SideBarComponent;

  @HostListener('click')
  click() {
    this.sideBar.toggle();
  }

}
@Component({
  selector: 'app-side-bar',
  templateUrl: './side-bar.component.html',
  styleUrls: ['./side-bar.component.css']
})
export class SideBarComponent {

  @HostBinding('class.is-open')
  isOpen = false;

  toggle() {
    this.isOpen = !this.isOpen;
  }

}
2. Communication through parent component
parent component holds sideBarIsOpened property which is passed to the side-bar component.
<app-side-bar-toggle (toggle)="toggleSideBar()"></app-side-bar-toggle>
<app-side-bar [isOpen]="sideBarIsOpened"></app-side-bar>
@Component({
  selector: 'my-app',
  templateUrl: './app.component.html',
  styleUrls: [ './app.component.css' ]
})
export class AppComponent {
  sideBarIsOpened = false;

  toggleSideBar(shouldOpen: boolean) {
    this.sideBarIsOpened = !this.sideBarIsOpened;
  }
}
@Component({
  selector: 'app-side-bar-toggle',
  templateUrl: './side-bar-toggle.component.html',
  styleUrls: ['./side-bar-toggle.component.css']
})
export class SideBarToggleComponent {

  @Output() toggle: EventEmitter<null> = new EventEmitter();

  @HostListener('click')
  click() {
    this.toggle.emit();
  }

}
@Component({
  selector: 'app-side-bar',
  templateUrl: './side-bar.component.html',
  styleUrls: ['./side-bar.component.css']
})
export class SideBarComponent {

  @HostBinding('class.is-open') @Input()
  isOpen = false;

}
3. Communication through service
should be used when you have component that is controlled or its state is asked from multiple instances
<app-side-bar-toggle></app-side-bar-toggle>
<app-side-bar></app-side-bar>
@Component({
  selector: 'app-side-bar-toggle',
  templateUrl: './side-bar-toggle.component.html',
  styleUrls: ['./side-bar-toggle.component.css']
})
export class SideBarToggleComponent {

  constructor(
    private sideBarService: SideBarService
  ) { }

  @HostListener('click')
  click() {
    this.sideBarService.toggle();
  }
}
@Component({
  selector: 'app-side-bar',
  templateUrl: './side-bar.component.html',
  styleUrls: ['./side-bar.component.css']
})
export class SideBarComponent {

  @HostBinding('class.is-open')
  isOpen = false;

  constructor(
    private sideBarService: SideBarService
  ) { }

  ngOnInit() {
    this.sideBarService.change.subscribe(isOpen => {
      this.isOpen = isOpen;
    });
  }
}
@Injectable()
export class SideBarService {

  isOpen = false;

  @Output() change: EventEmitter<boolean> = new EventEmitter();

  toggle() {
    this.isOpen = !this.isOpen;
    this.change.emit(this.isOpen);
  }

}
===================================================================================================================
How do you decide to create a new NgModule?
When we are dealing with medium or large apps, it includes discrete set of functionality. Administration, Dashboard, Bookings/Orders, Promotions are all examples of areas of our apps that, when linked together, make our app. We basically breakdown our app into smaller pieces called Features / Modules.

In the process of developing an app we might create a feature which we don't want to expose or create a feature which we want to lazy loading when the user decides it is time to revisit the feature. NgModules helps us to separate our features to logical units and load it when required.
===================================================================================================================
How will you inject custom header in your http call?

Injectable()
export class MoviesService {

  constructor(private http: Http) { }

  getMovies(): Observable<Movie[]> {
    var options = new RequestOptions({
      headers: new Headers({
        'Accept': 'application/json'
      })
    });

    return this.http
      .get('/movies.json', options)
      .map(resp => resp.json());
  }
}

This is an example of an Http request made by Chrome:

GET http://localhost:4200/movies.json HTTP/1.1
Host: localhost:4200
Connection: keep-alive
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36
Accept: */*
Referer: http://localhost:4200/
Accept-Encoding: gzip, deflate, sdch, br
Accept-Language: en-US,en;q=0.8,nl;q=0.6
If-None-Match: W/"3a4c7-1590757b458"
If-Modified-Since: Fri, 16 Dec 2016 11:15:05 GMT
 

And this is the same request made with FireFox:

GET http://localhost:4200/movies.json HTTP/1.1
Host: localhost:4200
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:49.0) Gecko/20100101 Firefox/49.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Referer: http://localhost:4200/
Connection: keep-alive
If-Modified-Since: Fri, 16 Dec 2016 11:15:05 GMT
If-None-Match: W/"3a4c7-1590757b458"
Cache-Control: max-age=0

Adding dynamic Http headers
@Injectable()
export class DefaultRequestOptions extends BaseRequestOptions {
  headers = new Headers({
    'Accept': 'application/json',
    'X-Requested-By':'Angular 2',
  });
 
  merge(options?: RequestOptionsArgs): RequestOptions {
    var newOptions = super.merge(options);
    newOptions.headers.set('X-Requested-At', new Date().toISOString());
    return newOptions;
  }
}
basic header
const httpOptions = {
  headers: new HttpHeaders({
    'Content-Type':  'application/json',
    'Authorization': 'my-auth-token'
  })
};
addHero (hero: Hero): Observable<Hero> {
  return this.http.post<Hero>(this.heroesUrl, hero, httpOptions)
    .pipe(
      catchError(this.handleError('addHero', hero))
    );
}
===================================================================================================================
How do you identify a structural directive in html?
see above questions
===================================================================================================================
How would you select a custom component to style it?
using class binding and property binding
===================================================================================================================
How would you select all the child components' elements?
The view children of a given component are the elements used within its template, its view.

@ViewChild() supports directive or component type as parameter, or the name (string) of a template variable.
@ViewChildren() also supports a list of names as comma separated list (currently no spaces allowed @ViewChildren('var1,var2,var3')).
@ContentChild() and @ContentChildren() do the same but in the light DOM (<ng-content> projected elements).

A @ViewChild decorator means, search inside this components template, it’s view, for this child component.
The parameter we pass as the first argument to @ViewChild is the type of the component we want to search for, if it finds more than one it will just give us the first one it finds.
@ViewChild(JokeComponent) jokeViewChild: JokeComponent;

@ViewChildren(JokeComponent) jokeViewChildren: QueryList<JokeComponent>; 

ContentChild & ContentChildren
The concept of a content child is similar to that of a view child but the content children of the given component are the child elements that are projected into the component from the host component.
To get a reference to that child we can use either the @ContentChild or the @ContentChildren decorators. They work in similar ways to the view child counterparts, @ContentChild returns one child and @ContentChildren returns a QueryList.

===================================================================================================================
How would you cache an observable data?
With the subscribe behavior of http observables in mind there are a few ways to implement caching.
One simple approach is to capture the result of the original http call in a cache variable and not resubscribe to the observable if we have a valid value in the cache variable. This works, but we are bypassing rxjs and have to add a fair amount of boilerplate code to manage state.

It turns out we can easily add caching to the observable by adding publishReplay(1) and refCount.
getFriends(){
    if(!this._friends){
      this._friends = this._http.get('./components/rxjs-caching/friends.json')
                                   .map((res:Response) => res.json().friends)
                                   .publishReplay(1)
                                   .refCount();
    }
    return this._friends;
}
publishReplay(1) tells rxjs to cache the most recent value which is perfect for single value http calls. refCount() is used to keep the observable alive for as long as there are subscribers.

Clearing Cache
Caching is great, but it's important to provide a way to clear the cache if we expect the data to change. In our simple example this can be done by setting the original observable to null.

clearCache(){
    this._friends = null;
}
===================================================================================================================
How would you save data from a form control?
export class HeroDetailComponent1 {
  name = new FormControl();
}
<h2>Hero Detail</h2>
<h3><i>Just a FormControl</i></h3>
<label class="center-block">Name:
  <input class="form-control" [formControl]="name">
</label>
creating form 
xport class HeroDetailComponent3 {
  heroForm: FormGroup; // <--- heroForm is of type FormGroup

  constructor(private fb: FormBuilder) { // <--- inject FormBuilder
    this.createForm();
  }

  createForm() {
    this.heroForm = this.fb.group({
      name: '', // <--- the FormControl called "name"
    });
  }
}
onSubmit() {
  this.hero = this.prepareSaveHero();
  this.heroService.updateHero(this.hero).subscribe(/* error handling */);
  this.rebuildForm();
}
===================================================================================================================
How Event Emitters works in Angular?
see previous examples
===================================================================================================================
Tell me about feature module and shared module?
easy 
===================================================================================================================
What would you not put in a shared module?
those services directives components which are used only once and in any other component or service because shared modules are shared across all applications and we dont want it to be heavily loaded .
===================================================================================================================
Why angular uses decorator?
Basically, decorators in Angular 2 apply metadata on classes leveraging the Reflect Metadata library. When Angular 2 will use the class, it will get this metadata to configure the expected behavior, for example in the case of a component.

There are four main types:

Class decorators, e.g. @Component and @NgModule
Property decorators for properties inside classes, e.g. @Input and @Output
Method decorators for methods inside classes, e.g. @HostListener
Parameter decorators for parameters inside class constructors, e.g. @Inject
===================================================================================================================
What is async validation and how is it done?
https://www.concretepage.com/angular-2/angular-custom-async-validator-example
Angular provides AsyncValidatorFn and AsyncValidator interfaces and NG_ASYNC_VALIDATORS provider for asynchronous validation. The methods of AsyncValidatorFn and AsyncValidator interfaces will return Promise<ValidationErrors | null> or Observable<ValidationErrors | null> . If validation fails, they contain ValidationErrors otherwise null.
interface AsyncValidatorFn { 
  (c: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null>
} 
AsyncValidatorFn has a method declaration that has argument as AbstractControl and it will contain latest value of the form control.
export function existingMobileNumberValidator(userService: UserService): AsyncValidatorFn {
  return (control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null> => {
    return userService.getUserByMobileNumber(control.value).map(
      users => {
        return (users && users.length > 0) ? {"mobNumExists": true} : null;
      }
    );
  };
  Any dependency can be passed as arguments. In the above validator function we are passing UserService as an argument. UserService is being used to fetch data over HTTP. 
  If validation is successful then null will be returned by our async validator and if there is validation error then value of type ValidationErrors i.e. {"mobNumExists": true} will be returned
  To display error message we can access the value of mobNumExists using errors object as errors.mobNumExists 
constructor(formState: any = null, 
              validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null, 
              asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null) 
1.Using FormControl
In the absence of synchronous validators, we will use asynchronous validators as following.
mobileNumber = new FormControl('', 
   null,
  [ existingMobileNumberValidator(this.userService),
    blackListedMobileNumberValidator(this.userService) ] //async validators
);
We have passed null for synchronous validators. 
2.Using FormGroup
userForm = new FormGroup({
   mobileNumber: new FormControl('', 
         [ Validators.required, Validators.maxLength(10) ], //sync validators
         [ existingMobileNumberValidator(this.userService),
           blackListedMobileNumberValidator(this.userService) ]), //async validators

}); 
3.Using FormBuilder
this.userForm = this.formBuilder.group({
   mobileNumber: ['', 
        [ Validators.required, Validators.maxLength(10) ], //sync validators
        [ existingMobileNumberValidator(this.userService),
          blackListedMobileNumberValidator(this.userService) ] //async validators
   ],
}); 
<input formControlName="mobileNumber"> Error messages can be displayed as following.
<div *ngIf="mobileNumber.errors" class = "error"> 
  <div *ngIf="mobileNumber.errors.required"> 
     Mobile number required.
  </div>			   
  <div *ngIf="mobileNumber.errors.maxlength"> 
     Mobile number must be 10 digit max.
  </div>
  <div *ngIf="mobileNumber.errors.mobNumExists"> 
     Mobile number already exists. 
  </div>	
  <div *ngIf="mobileNumber.errors.blackListedMobNum"> 
     Black listed mobile number.
  </div>	
</div> 

Angular provides AsyncValidator interface using which we create custom async validator directive
interface AsyncValidator extends Validator { 
  validate(c: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null>
} 
import { Directive } from '@angular/core';
import { AsyncValidator, NG_ASYNC_VALIDATORS, AbstractControl, ValidationErrors } from '@angular/forms';
import { Observable } from "rxjs/Observable";
import 'rxjs/add/operator/map';

@Directive({
  selector: '[mobNumExists][formControlName],[mobNumExists][formControl],[mobNumExists][ngModel]',
  providers: [{provide: NG_ASYNC_VALIDATORS, useExisting: ExistingMobileNumberValidatorDirective, multi: true}]
})
export class ExistingMobileNumberValidatorDirective implements AsyncValidator {
  constructor(private userService: UserService) {  }

  validate(control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null> {
    return this.userService.getUserByMobileNumber(control.value).map(
      users => {
        return (users && users.length > 0) ? {"mobNumExists": true} : null;
      }
    );
  }
} 
NG_ASYNC_VALIDATORS is a provider for asynchronous validators and it is used with multi: true
In our async validator directive, we have following selector.
[mobNumExists][formControlName]
[mobNumExists][formControl]
[mobNumExists][ngModel] 
If we are creating async validator using AsyncValidatorFn and AsyncValidator both, we can utilize the method definition of AsyncValidatorFn into the validate method of AsyncValidator as following.
export function existingMobileNumberValidator(userService: UserService): AsyncValidatorFn {
  return (control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null> => {
    return userService.getUserByMobileNumber(control.value).map(
      users => {
        return (users && users.length > 0) ? {"mobNumExists": true} : null;
      }
    );
  };
}

@Directive({
  selector: '[mobNumExists][formControlName],[mobNumExists][formControl],[mobNumExists][ngModel]',
  providers: [{provide: NG_ASYNC_VALIDATORS, useExisting: ExistingMobileNumberValidatorDirective, multi: true}]
})
export class ExistingMobileNumberValidatorDirective implements AsyncValidator {
  constructor(private userService: UserService) {  }

  validate(control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null> {
     return existingMobileNumberValidator(this.userService)(control);
  }
} 
===================================================================================================================
Why do you need type definitions?
My understanding of typescript definition files is that they are used to provide tooling support and are not required to compile typescript.
Dynamically typed languages like JavaScript provide a lot of expressiveness and power to the programmer. By not having to think about strict types, a program is more maleable since it will run no matter what, allowing the programmer to write code very quickly.
This decrease in velocity can be attributed to a couple of factors.
1.Bugs introduced by type mismatches (such as null types) take time away from feature development.
2.Each time existing code is examined, the programmer needs to figure out what the intended types are again.
===================================================================================================================
Which components will be notified when an event is emitted?
Let’s finalise the basics of parent-child and child-parent communication by introducing EventEmitter and @Output
@Component({...})
export class CounterComponent {
  @Input()
  count: number = 0;
  @Output()
  change: EventEmitter<number> = new EventEmitter<number>();
  increment() {
    this.count++;
    this.change.emit(this.count);
  }
  decrement() {
    this.count--;
    this.change.emit(this.count);
  }
}

@Component({
  selector: 'app-root',
  template: `
    <div class="app">
      Parent: {{ myCount }}
      <counter
        [count]="myCount"
        (update)="countChange($event)">
      </counter>
    </div>
  `
})
export class AppComponent {
  myCount: number = 10;
  countChange(event) {
    this.myCount = event;
  }
}

===================================================================================================================
Why would you export from ngModule?
An export what you put is the exports property of the @NgModule decorator. It enables an Angular module to expose some of its components/directives/pipes to the other modules in the applications. Without it, the components/directives/pipes defined in a module could only be used in that module.
===================================================================================================================
Why is a service provided in a lazy loaded module visible only to that module?
Unlike providers of the modules loaded at launch, providers of lazy loaded modules are module-scoped.
When the Angular router lazy-loads a module, it creates a new execution context. That context has its own injector which is a direct child of the application injector.
The router adds the lazy module's providers and the providers of its imported modules to this child injector.
These providers are insulated from changes to application providers with the same lookup token. When the router creates a component within the lazy loaded context, Angular prefers service instances created from these providers to the service instances of the application root injector.
===================================================================================================================
Why is it bad if SharedModule provides a service to a lazy loaded module?
This question arose in the Angular Module chapter when we discussed the importance of keeping providers out of the SharedModule.
Suppose we had listed the UserService in the module's providers (which we did not). Suppose every module imports this SharedModule (which they all do).

When the app starts, Angular eagerly loads the AppModule and the ContactModule.
Both instances of the imported SharedModule would provide the UserService. Angular registers one of them in the root app injector (see above). Then some component injects UserService, Angular finds it in the app root injector, and delivers the app-wide singleton UserService. No problem.
Now consider the HeroModule which is lazy loaded!
When the router lazy loads the HeroModule, it creates a child injector and registers the UserService provider with that child injector. The child injector is not the root injector.
When Angular creates a lazy HeroComponent, it must inject a UserService. This time it finds a UserService provider in the lazy module's child injector and creates a new instance of the UserService. This is an entirely different UserService instance than the app-wide singleton version that Angular injected in one of the eagerly loaded components.
That's almost certainly a mistake.
===================================================================================================================
Can you explain the difference between ActivatedRoute and RouterState?
After the end of each successful navigation lifecycle, the router builds a tree of ActivatedRoute objects that make up the current state of the router.
 We can access the current RouterState from anywhere in our application using the Router service and the routerState property.
RouterState is the current state of the router including a tree of the currently activated routes in our application along convenience methods for traversing the route tree.
Since ActivatedRoute can be reused, ActivatedRouteSnapshot is an immutable object representing a particular version of ActivatedRoute.
 It exposes all the same properties as ActivatedRoute as plain values, while ActivatedRoute exposes them as observables.
===================================================================================================================
Which service will you put in the module and why?
services whose single instance is required across all component/pipes we declare them in module
because if we use service as injector in every component then multiple instances of them may get created.
===================================================================================================================
What is a factory Component?
Angular’s ComponentFactory is nothing more than a factory of components; the name is self-explanatory. It is a very powerful way to dynamically add components to your application by using metadata.
First, let’s create a view container as the placeholder for our components and add a template reference to it:
@Component({
  selector: 'my-app',
  template: `
    <div>
      <h2>Lets dynamically create some components!</h2>
      <button (click)="createHelloWorldComponent()">Create Hello World</button>
      <button (click)="createWorldHelloComponent()">Create World Hello</button>
    </div>
    <dynamic-component [componentData]="componentData"></dynamic-component>
  `,
})
export class App {  
  componentData = null;

  createHelloWorldComponent(){
    this.componentData = {
      component: HelloWorldComponent,
      inputs: {
        showNum: 9
      }
    };
  }

  createWorldHelloComponent(){
    this.componentData = {
      component: WorldHelloComponent,
      inputs: {
        showNum: 2
      }
    };
  }
}
----------------
import {Component, ViewContainerRef, ViewChild, ReflectiveInjector, ComponentFactoryResolver} from '@angular/core';  
import HelloWorldComponent from './hello-world-component';  
import WorldHelloComponent from './world-hello-component';

@Component({
  selector: 'dynamic-component',
  entryComponents: [HelloWorldComponent, WorldHelloComponent], // Reference to the components must be here in order to dynamically create them
  template: `
    <div #dynamicComponentContainer></div>
  `,
})
export default class DynamicComponent {  
  currentComponent = null;
  @ViewChild('dynamicComponentContainer', { read: ViewContainerRef }) dynamicComponentContainer: ViewContainerRef;

  constructor(private resolver: ComponentFactoryResolver) {

  }

  …
}
---------------
@Input() set componentData(data: {component: any, inputs: any }) {
    if (!data) {
      return;
    }

    // Inputs need to be in the following format to be resolved properly
    let inputProviders = Object.keys(data.inputs).map((inputName) => {return {provide: inputName, useValue: data.inputs[inputName]};});
    let resolvedInputs = ReflectiveInjector.resolve(inputProviders);

    // We create an injector out of the data we want to pass down and this components injector
    let injector = ReflectiveInjector.fromResolvedProviders(resolvedInputs, this.dynamicComponentContainer.parentInjector);

    // We create a factory out of the component we want to create
    let factory = this.resolver.resolveComponentFactory(data.component);

    // We create the component using the factory and the injector
    let component = factory.create(injector);

    // We insert the component into the dom container
    this.dynamicComponentContainer.insert(component.hostView);

    // Destroy the previously created component
    if (this.currentComponent) {
      this.currentComponent.destroy();
    }

    this.currentComponent = component;
  }
===================================================================================================================
What is lazy loading and why will you use it?
===================================================================================================================
What is Ahead of time (AOT) compilation and why will you use it?
The Angular Ahead-of-Time (AOT) compiler converts your Angular HTML and TypeScript code into efficient JavaScript code during the build phase before the browser downloads and runs that code
An Angular application consists largely of components and their HTML templates. Before the browser can render the application, the components and templates must be converted to executable JavaScript by an Angular compiler.
Why compile with AOT?
Faster rendering- the browser downloads a pre-compiled version of the application
Fewer asynchronous requests- compiler inlines external HTML templates and CSS style sheets within the application JavaScript
Smaller Angular framework download size- There's no need to download the Angular compiler if the app is already compiled
Detect template errors earlier - AOT compiler detects and reports template binding errors during the build step before users can see them
Better security - compiles HTML templates and components into JavaScript files long before they are served to the client
===================================================================================================================
What are some of the Angular Style Guide suggestions you follow on your code? Why?
https://angular.io/guide/styleguide

The structure should follow these 4 basic guidelines. When I find my structure is not feeling comfortable, I go back and revisit these LIFT guidelines
Locating our code is easy
Identify code at a glance
Flat structure as long as we can
Try to stay DRY (Don't Repeat Yourself) or T-DRY
===================================================================================================================
What is wildcard state?
https://www.jvandemo.com/the-7-step-process-of-angular-router-navigation/

wildcard state tell angular that if no routing module is found just revert it to component that is used earlier
===================================================================================================================
How do you put animation between two states? 
https://angular.io/guide/animations
Motion is an important aspect in the design of modern web applications. Good user interfaces transition smoothly between states with engaging animations that call attention where it's needed. Well-designed animations can make a UI not only more fun but also easier to use.
toggleState() {
    this.state = this.state === 'active' ? 'inactive' : 'active';
  }
  import {  Component,  Input} from '@angular/core';
import {  trigger,  state,  style,  animate,  transition} from '@angular/animations';
animations: [
  trigger('heroState', [
    state('inactive', style({
      backgroundColor: '#eee',
      transform: 'scale(1)'
    })),
    state('active',   style({
      backgroundColor: '#cfd8dc',
      transform: 'scale(1.1)'
    })),
    transition('inactive => active', animate('100ms ease-in')),
    transition('active => inactive', animate('100ms ease-out'))
  ])
]
template: `
  <ul>
    <li *ngFor="let hero of heroes"
        [@heroState]="hero.state"
        (click)="hero.toggleState()">
      {{hero.name}}
    </li>
  </ul>
`,
state('inactive', style({
  backgroundColor: '#eee',
  transform: 'scale(1)'
})),
state('active',   style({
  backgroundColor: '#cfd8dc',
  transform: 'scale(1.1)'
})),
===================================================================================================================
What would be a good use for NgZone service?
https://angular.io/api/core/NgZone
Angular 2 runs inside of its own special zone called NgZone and this special zone extends the basic functionality of a zone to facilitate change detection.
It is Running inside a zone allows to detect when asynchronous tasks.
If you change or update your internal application code or view and it is detecting the applications changes with help of NgZone.
constructor(_ngZone:NgZone) {
    window.onresize = (e) =>
    {
        _ngZone.run(() => {
            this.width = window.innerWidth;
            this.height = window.innerHeight;
        });
    };
}
===================================================================================================================
How would you protect a component being activated through the router?
canActivate
===================================================================================================================
How would you insert an embedded view from a prepared TemplateRef?
View Containers are containers where one or more Views can be attached. Views represent some sort of layout to be rendered and the context under which to render it. View containers are anchored to components and are responsible for generating its output so this means that changing which views are attached to the view container affect the final rendered output of the component.
Two types of views can be attached to a view container: Host Views which are linked to a Component, and Embedded Views which are linked to a template. Since structural directives interact with templates, we are interested in using Embedded Views in this case.
You can create an embedded view using createEmbeddedView method then attach that view to the DOM via ViewContainerRef:

@Component({
    selector: 'app-root',
    template: `
        <ng-template #template let-name='fromContext'><div>{{name}}</ng-template>
        <ng-container #vc></ng-container>
    `
})
export class AppComponent implements AfterViewChecked {
    @ViewChild('template', { read: TemplateRef }) _template: TemplateRef<any>;
    @ViewChild('vc', {read: ViewContainerRef}) vc: ViewContainerRef;
    constructor() { }

    ngAfterViewChecked() {
        const view = this._template.createEmbeddedView({fromContext: 'John'});
        this.vc.insert(view);
    }
}
ngAfterViewChecked() {
    this.vc.createEmbeddedView(this._template, {fromContext: 'John'});
}
===================================================================================================================
What is attribute directive and why will you use it?
An attribute directive minimally requires building a controller class annotated with @Directive, which specifies the selector that identifies the attribute. The controller class implements the desired directive behavior.

This page demonstrates building a simple appHighlight attribute directive to set an element's background color when the user hovers over that element.
import { Directive, ElementRef } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
    constructor(el: ElementRef) {
       el.nativeElement.style.backgroundColor = 'yellow';
    }
}
To use the new HighlightDirective, add a paragraph (<p>) element to the template of the root AppComponent and apply the directive as an attribute.
<p appHighlight>Highlight me!</p>
===================================================================================================================
How will you intercept http to inject header to each http call?
import { HTTP_INTERCEPTORS } from ‘@angular/common/http’;
@Injectable()
export class HttpsRequestInterceptor implements HttpInterceptor {
 intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
const dupReq = req.clone({ headers: req.headers.set(‘Consumer-Secret’, ‘some sample key’) });
return next.handle(dupReq);
 }
};
@NgModule({
 providers: [
 { provide: HTTP_INTERCEPTORS, useClass: HttpsRequestInterceptor, multi: true }
 ]
})
export class InterceptorModule { }
----------------
antoher example
import { Injectable} from '@angular/core';
import { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest } from '@angular/common/http';

@Injectable()
export class MyFirstInterceptor implements HttpInterceptor {
    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
        console.log(req);
        return next.handle(req);
    }
}
===================================================================================================================
How would you create a component to display error messages throughout your application?
===================================================================================================================
How will you parallelize multiple observable call?
When we get the character back, we then need to fetch that character’s homeworld from the same API but a different REST endpoint. This example is sequential. Make one request then the next.
@Component({
  selector: 'app-root',
  templateUrl: 'app/app.component.html'
})
export class AppComponent {
  loadedCharacter: {};
  constructor(private http: HttpClient) { }
  
  ngOnInit() {
    this.http.get('/api/people/1').subscribe(character => {
      this.http.get(character.homeworld).subscribe(homeworld => {
        character.homeworld = homeworld;
        this.loadedCharacter = character;
      });
    });
  }
}
===================================================================================================================
How will you put one async call before another?
someFunction() {
  return returnsObservable()
    .subscribe(
      event => doForEachEvent(),
      error => handleError(),
      () => doSomethingNext()
          .then(result => doSomethingAfterThat());
}
doSomethingNext() is executed after the last event and doSomethingAfterThat() is again chained with then() to show how to mix observable and promise. doSomething()
===================================================================================================================
How can you use web worker in angular app?
http://blog.brakmic.com/introduction-to-angular-2-part-5-webworkers/
A WebWorker is a JavaScript file containing implementations of the onmessage event handler and the postMessage method. 
WebWorkers react to incoming messages by executing onmessage handlers which usually end up calling the postMessage methods. 
There are, of course, another event handlers available: onchange, onerror etc.  
But the most important thing to be aware of isn’t the interface itself.
 It’s actually the environment in which WebWorkers run. U
 nlike most other browser scripts they must not access the DOM and have to run in a thread separated from the one that instantiated them.
 The only way to send data from and to WebWorkers is via message passing (that is, postMessage)
 . In our case we’re building a simple app comprising of three components and a single web worker.
 import { Component,
         OnInit, ChangeDetectorRef,
         ChangeDetectionStrategy } from '@angular/core';

@Component({
    selector: 'my-app',
    templateUrl: './my-app.component.html',
    styleUrls: ['./my-app.component.scss'],
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class MyAppComponent implements OnInit {
    private worker: Worker;
    private customersList: any[] = [];
    private lastEntry: string = '';

    constructor(private cd: ChangeDetectorRef) { }

    public ngOnInit() {
        this.initWebWorker();
    }
    /*
    * Activate WebWorker which resides in a separate JS file
    */
    private initWebWorker() {
        this.worker = new Worker('worker.js');
        // `on-message` callback to receive data from worker
        this.worker.addEventListener('message', (e: MessageEvent) => {
          this.customersList = e.data;
          this.lastEntry = `Got customers list with ${this.customersList.length} entries`;
          this.cd.markForCheck();
        });
    }
    /*
    * Post a command to the worker
    */
    private onGetCustomersClicked($event) {
        this.worker.postMessage({ table: 'Customers'});
    }
    /*
    * React to row selections
    */
    private onRowSelected($event: { row: any }) {
        this.lastEntry = `${$event.row.ContactName} selected`;
    }
}
===================================================================================================================
What tools would you use to find a performance issue in your code?
sonarqube
===================================================================================================================
What are some ways you may improve your website's scrolling performance?
Things you can do to improve performance issues on your website:
1.	Page-level keyword answers and content level metrics
2.	Dwell Time or Long Click Metrics
3.	Existence and Reliability of Verified Real-world Business Details
4.	Use of Responsive design for Uniform Content
5.	Less duplicate content per page and site uniqueness
6.	Solution-rich custom content
7.	Entire Site Should be Mobile Optimized
8.	Speed up Your Website: Lightning Fast Loading Pages
9.	User searches for queries in tandem with a brand name, URL or site
10.	Number of Clicks from Google SERPs to your Site
11.	Prioritizing HTTPS/SSL
12.	Links
===================================================================================================================
Explain the difference between layout, painting and compositing.
===================================================================================================================
How can you cancel a router navigation?
===================================================================================================================
How would you animate routing?
We used static routes to create the different navigation links (lines 5–6). To style the current section, we used the routerLinkActive directive. So for example, when we navigate to Home, it will add the active class and change rendering accordingly.	
we need to add routerTransition, our animation trigger, to the component metadata (line 3). Then, we can bind @routerTransition in the main element
Component({
  selector: 'my-app',
  animations: [ routerTransition ],
  template: `
    <main [@routerTransition]="getState(o)">
      <router-outlet #o="outlet"></router-outlet>
    </main>
  `
})
export class App {
  getState(outlet) {
    return outlet.activatedRouteData.state;
  }
}
https://medium.com/google-developer-experts/angular-supercharge-your-router-transitions-using-new-animation-features-v4-3-3eb341ede6c8
===================================================================================================================
How would you cancel a promise on which you are waiting?
canceller.resolve() should be called when you actually want to cancel that request. If the request was already made and you resolve the canceller, nothing will happen... you can´t cancel a finished request.
canceller.resolve() will evoke the error callback of your request promise. One Note here: in order to determine if request was cancelled and did not fail because of any other error, I check for data.status === 0
var requestPromise = $http({
        url: 'data/en.json',
        timeout: canceller.promise
    });

    requestPromise.
        success(function(data, status, headers, config) {
            // Everything fine and not cancelled
        }).
        error(function(data, status, headers, config) {
            if(data.status === 0) {
                // Request cancelled
            }
            else {
                // Other error
                throw 'Error ' + status
            }
        });

    // This would happen at some later point in your code
    canceller.resolve();
===================================================================================================================
When does a lazy loaded module is loaded?
Modules that are lazily loaded will only be loaded when the user navigates to their routes.
===================================================================================================================
Why angular uses url segment?
https://vsavkin.com/angular-router-understanding-router-state-7b5b95a12eab
https://vsavkin.com/angular-router-understanding-redirects-2826177761fc
A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix parameters associated with the segment.
Interface ActivatedRouteSnapshot {
  url: UrlSegment[];
  params: {[name:string]:string};
  data: {[name:string]:any};

  queryParams: {[name:string]:string};
  fragment: string;
  
  root: ActivatedRouteSnapshot;
  parent: ActivatedRouteSnapshot;
  firstchild: ActivatedRouteSnapshot;
  children: ActivatedRouteSnapshot[];
}
RouterStateSnapshot is a tree of activated route snapshots. Every node in this tree knows about the “consumed” URL segments, the extracted parameters, and the resolved data
===================================================================================================================
How will you make angular app secure?.
Keep current with the latest Angular library releases. We regularly update the Angular libraries, and these updates may fix security defects discovered in previous versions. Check the Angular change log for security-related updates.

Don't modify your copy of Angular. Private, customized versions of Angular tend to fall behind the current version and may not include important security fixes and enhancements. Instead, share your Angular improvements with the community and make a pull request.

Avoid Angular APIs marked in the documentation as “Security Risk.” For more information, see the Trusting safe values section of this page.
Cross-site scripting (XSS) enables attackers to inject malicious code into web pages. Such code can then, for example, steal user data (in particular, login data) or perform actions to impersonate the user. This is one of the most common attacks on the web.
Angular treats all values as untrusted by default. When a value is inserted into the DOM from a template, via property, attribute, style, class binding, or interpolation, Angular sanitizes and escapes untrusted values
Sanitization is the inspection of an untrusted value, turning it into a value that's safe to insert into the DOM. In many cases, sanitization doesn't change a value at all. Sanitization depends on context: a value that's harmless in CSS is potentially dangerous in a URL.
Content Security Policy (CSP) is a defense-in-depth technique to prevent XSS. To enable CSP, configure your web server to return an appropriate Content-Security-Policy HTTP header.
https://auth0.com/blog/angular-2-authentication/
===================================================================================================================
How will you localize numbers currencies and dates?
A module to translate texts & a module to translate texts, dates & numbers
A module for validation by locales (numbers)
Direct & Asynchronous loading of translation data
Available providers for Asynchronous loading:
Static (json files)
WebAPI (json format)
Fallback
Custom
Caching of the http requests
npm install angular-l10n --save 
Angular CLI No need to set up anything, just import it in your code.
To get the translation, this library uses pure pipes
Application internationalization is a many-faceted area of development, focused on making applications available and user-friendly to a worldwide audience.
https://angular.io/guide/i18n
===================================================================================================================
What is the best way to use translation in your app?
<p>{{ 'hello world' | translate }}</p>
this.translatedText = this.translate.instant('hello world');
this.translate.use('es'); 
https://scotch.io/tutorials/simple-language-translation-in-angular-2-part-1
===================================================================================================================
How will you setup different environment build differently for your app
===================================================================================================================
How will you use scss or css preprocessing with your application?	
===================================================================================================================
How will you optimize image/svg in your angular app?
https://blog.thoughtram.io/angular/2017/02/02/making-your-angular-app-fast.html
===================================================================================================================
How would you make sure an api call that needs to be called only once but with multiple conditions? Example: if you need to get some data in multiple routes but, once you get it, you can reuse it in the routes that needs it, therefor no need to make another call to your backend apis.
===================================================================================================================
If you need to respond to two different Observable/Subject with one callback function, how would you do it? (ex: if you need to change the url through route parameters and with prev/next buttons).
===================================================================================================================
Why unsubscribing is important?
===================================================================================================================
What is the difference between map and flatmap?
Here is an example of the difference, as a spark-shell session:

First, some data - two lines of text:

val rdd = sc.parallelize(Seq("Roses are red", "Violets are blue"))  // lines

rdd.collect

    res0: Array[String] = Array("Roses are red", "Violets are blue")
Now, map transforms an RDD of length N into another RDD of length N.

For example, it maps from two lines into two line-lengths:

rdd.map(_.length).collect

    res1: Array[Int] = Array(13, 16)
But flatMap (loosely speaking) transforms an RDD of length N into a collection of N collections, then flattens these into a single RDD of results.

rdd.flatMap(_.split(" ")).collect

    res2: Array[String] = Array("Roses", "are", "red", "Violets", "are", "blue")
We have multiple words per line, and multiple lines, but we end up with a single output array of words

Just to illustrate that, flatMapping from a collection of lines to a collection of words looks like:

["aa bb cc", "", "dd"] => [["aa","bb","cc"],[],["dd"]] => ["aa","bb","cc","dd"]
The input and output RDDs will therefore typically be of different sizes for flatMap.

Finally, one useful special case is mapping with a function which might not return an answer, and so returns an Option. We can use flatMap to filter out the elements that return None and extract the values from those that return a Some:

val rdd = sc.parallelize(Seq(1,2,3,4))

def myfn(x: Int): Option[Int] = if (x <= 2) Some(x * 10) else None

rdd.flatMap(myfn).collect

    res3: Array[Int] = Array(10,20)
(noting here that an Option behaves rather like a list that has either one element, or zero elements)
===================================================================================================================
Whare are the different ways you can create an Observable?
===================================================================================================================
What is forkJoin, zip, share?
===================================================================================================================
Difference between hot and cold observables.
===================================================================================================================
How would you debug a typescript file?
===================================================================================================================
How do you implement interface in typescript?
===================================================================================================================
How would you call base class constructor from child class in typescript?
===================================================================================================================
What is typescript language service?
===================================================================================================================
How to declare a custom type?
===================================================================================================================
what are some disadvantages of typescirpt?
===================================================================================================================
Why would you use angular cli?
===================================================================================================================
How would you run unit test?
===================================================================================================================
How do you create application to use scss?
===================================================================================================================
How to inject base href?
===================================================================================================================
How would you extract webpack config from angular cli project?
===================================================================================================================
What is the use of codelyzer?
===================================================================================================================
Will you use Angular Material2?
===================================================================================================================
How would you set different config in different deployment server?
===================================================================================================================
What do you know about ES6?
===================================================================================================================
What is ngUpgrage? Do you know how you can run angularJS and angular side by side?
===================================================================================================================
How do you mock a service to inject in a unit test?
===================================================================================================================
