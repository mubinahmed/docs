1 - What are the differences between null and undefined?

undefined means, value of the variable is not defined. JavaScript has a global variable undefined whose value is "undefined" and typeof undefined is also "undefined". Remember, undefined is not a constant or a keyword. undefined is a type with exactly one value: undefined. Assigning a new value to it does not change the value of the type undefined.

null means empty or non-existent value which is used by programmers to indicate “no value”. null is a primitive value and you can assign null to any variable. null is not an object, it is a primitive value. For example, you cannot add properties to it. Sometimes people wrongly assume that it is an object, because typeof null returns "object".

=======================================================================================================
What are the differences between == and ===?

== will not check types and === will check whether both sides are of same type
=== compares the types and values. Hence, if both sides are not same type, answer is always false
=======================================================================================================
How would you compare two objects in JavaScript?

objects like arrays, dates, and user defined objects are compared by their reference.
This means it compares whether two objects are referring to the same location in memory.
Equality check will check whether two objects have same value for same property.
you can get the keys for both the objects. If the number of properties doesn't match, these two objects are not equal.
Secondly, you will check each property whether they have the same value
=======================================================================================================
falsy: In javascript 6 things are falsy and they are- false, null, undefined, '', 0, NaN
truthy: There are only two truthy things- true and everything that is not false
=======================================================================================================
Question: Is 'false' is false?
Answer: No. Because, it's a string with length greater than 0. Only empty string is false.

Question: Is ' ' is false?
Answer: No. Because, it's not an empty string. There is a white space in it.

Question: What about {}?
Answer: true. It's an object. An object without any property is an object can't be falsy.

Question: Tell me about []?
Answer: This is also truthy. It's an array object (array is child of object) is truthy.

Question: You talked bout '' to be falsy. What about new String('')?
Answer: Though you are passing empty string to the string constructor, it is creating an String object. More precisely a instance of String object. It becomes an object. Hence, it is not false. so, it is truthy.

Question: Tell me about new Boolean(false)
Answer: truthy. As it creates an instance of the Boolean object which is an object. Object is truthy.

Question: Boolean(function(){})
Answer: true if you pass a truthy value to Boolean, it will be true.

Question: Boolean(/foo/)
Answer: true

Question: true%1
Answer: 0. When you are trying to find reminder of true, true becomes 1 and reminder of 1 while dividing by 1 is 0. you will get same result if you doe false%1

Question: ''%1
Answer: 0
=======================================================================================================
As [] is true, []==true should also be true. right?

if([]){console.log('its true')} ---- is true
but []==true is false as it compares type of object string and boolean
=======================================================================================================
Extend Core Object
How could you write a method on instance of a date which will give you next day?
I have to declare a method on the prototype of Date object. To get access to the current value of the instance of the date, i will use this
Date.prototype.nextDay = function(){
var currentDate = this.getDate();
return new Date(this.setDate(currentDate +1));
}
=======================================================================================================
bind
If you want to use an arbitrary object as value of this, how will you do that?
bind allows you to borrow a method and set the value of this without calling the function. 
It simply returns an exact copy of the function with new value of this. 
You can reuse the same function with new value of this without harming the old one.
var monica = {
name: 'Monica Geller',
total: 400,
deductMontlyFee: function(fee){
 this.total = this.total - fee;
 return this.name + ' remaining balance is '+ this.total; 
}
}
var rachel = {name: 'Rachel Green', total: 1500};
var rachelFeeDeductor = monica.deductMonthlyFee.bind(rachel, 200);

rachelFeeDeductor(); //"Rachel Green remaining balance is 1300"
rachelFeeDeductor(); //"Rachel Green remaining balance is 1100"
=======================================================================================================
If an older browser dont have bind function, how will you shim it ?

Function.prototype.bind = Function.prototype.bind || function(context){
var self = this;
return function(){
return self.apply(context, arguments);
};
}
=======================================================================================================
arguments and call
Write a simple function to tell whether 2 is passed as parameter or not?
function isTwoPassed(){
var args = Array.prototype.slice.call(arguments);
return args.indexOf(2) != -1;
}

isTwoPassed(1,4) //false
isTowPassed(5,3,1,2) //true

arguments is a local variable, available inside all functions that provides a collection of all the arguments passed to the function. arguments is not an array rather an array like object.
Danger: Don't name any argument as "arguments" or dont create any local variable named as "arguments", this will override build in arguments object.
=======================================================================================================
apply
Question: How could you use Math.max to find the max value in an array?
Answer: Use apply on Math.max and pass the array as apply takes an array of arguments
function getMax(arr){
return Math.max.apply(null, arr);  
}
call and apply, both takes the value of this as first parameter. However, call takes a collection of arguments after first parameter whereas apply use an array of arguments as second parameter.
=======================================================================================================
What the heck is this in JavaScript?
At the time of execution of every function, JavaScript engine sets a property to the function called this which refer to the current execution context. this is always refer to an object and depends on how function is called. There are 7 different cases where the value of this varies.

1.In the global context or inside a function this refers to the window object.
2.Inside IIFE (immediate invoking function) if you use "use strict", value of this is undefined. To pass access window inside IIFE with "use strict", you have to pass this.
3.While executing a function in the context of an object, the object becomes the value of this
4.Inside a setTimeout function, the value of this is the window object.
5.If you use a constructor (by using new keyword) to create an object, the value of this will refer to the newly created object.
6.You can set the value of this to any arbitrary object by passing the object as the first parameter of bind, call or apply
7.For dom event handler, value of this would be the element that fired the event
=======================================================================================================
Question: What is typeof []
Answer: Object. Actually Array is derived from Object. If you want to check array use Array.isArray(arr)

Question: What is typeof arguments
Answer: Object. arguments are array like but not array. it has length, can access by index but can't push pop, etc.

Question: What is 2+true
Answer: 3. The plus operator between a number and a boolean or two boolean will convert boolean to number. Hence, true converts to 1 and you get result of 2+1

Question: What is '6'+9
Answer: 69. If one of the operands of the plus (+) operator is string it will convert other number or boolean to string and perform a concatenation. For the same reason, "2"+true will return "2true"

Question: What is the value of 4+3+2+"1"
Answer: 91 . The addition starts from the left, 4+3 results 7 and 7+2 is 9. So far, the plus operator is performing addition as both the operands are number. After that 9 + "1" where one of the operands is string and plus operator will perform concatenation.

Question: What is the value of "1"+2+4
Answer: "124". For this one "1" + 2 will produce "12" and "12"+4 will generates "124".

Question: What is the value of -'34'+10
Answer: -24. minus(-) in front of a string is an unary operator that will convert the string to a number and will make it negative. Hence, -'34' becomes, -34 and then plus (+) will perform simple addition as both the operands are number.

Question: What is the value of +'dude'
Answer: NaN. The plus (+) operator in front of a string is an unary operator that will try to convert the string to number. Here, JavaScript will fail to convert the "dude" to a number and will produce NaN.

Question: If you have var y = 1, x = y = typeof x; What is the value of x?
Answer: "undefined"

Question: for var a = (2, 3, 5); what is the value of a?
Answer: 5. The comma operator evaluates each of its operands (from left to right) and returns the value of the last operand. ref: MDN

Question: for var a = (1, 5 - 1) * 2 what is the value of a?
Answer: 8

Question: What is the value of !'bang'
Answer: false. ! is NOT. If you put ! in front of truthy values, it will return false. Using !! (double bang) is a tricky way to check anything truthy or falsy by avoiding implicit type conversion of == comparison.

Question: What is the value of parseFloat('12.3.4')
Answer: 12.3

Question: What is the value of Math.max([2,3,4,5]);
Answer: NaN

Question: 3 instanceof Number
Answer: false

Question:null == undefined
Answer: true

Question:What is the value of !!function(){};
Answer: true

Question: What is the value of typeof bar
Answer: "undefined"

Question: What is the value of typeof null
Answer: "object"

Question: If var a = 2, b =3 what would be value of a && b
Answer: 3

Question: What would be consoled var foo = 'outside'; function logIt(){console.log(foo); var foo = 'inside';} logIt();
Answer: undefined

Question: What is -5%2
Answer:-1. the result of remainder always get the symbol of first operand

Question: Why .1+.2 != .3
Answer:

Question: 42..toString()
Anwser: "42"

Question: 4.2..toString
Anwser: //SyntaxError: Unexpected token .

Question:42 . toString()
Anwser: "42"

Question: typeof(NaN)
Anwser:"number"

Question: 2 in [1,2]
Anwser: false. Because "in" returns whether a particular property/index available in the Object. In this case object has index 0 and 1 but don't have 2. Hence you get false.


=======================================================================================================
Pass by value or by reference
Question: Does JavaScript pass parameter by value or by reference?
Primitive type (string, number, etc.) are passed by value and objects are passed by reference. If you change a property of the passed object, the change will be affected.
=======================================================================================================
memoization
Question: How could you implement cache to save calculation time for a recursive fibonacci function?
you could use poor man's memoization with a global variable. If fibonacci is already calculated it is served from the global memo array otherwise it is calculated.
var memo = [];

function _fibonacci(n) {
if(memo[n]){    
return memo[n];
}
else if (n < 2){
 return 1;
}else{
 fibonacci(n-2) + fibonacci(n-1);
}
}
=======================================================================================================
How could you cache execution of any function?
You could have a method where you will pass a function and it will internally maintain a cache object where calculated value will be cached. When you will call the function with same argument, the cached value will be served.

What if you are passing more than one argument?
First we have to use arguments to get all the parameters passed to the function and then we can generate key for the cache object. Generating key for the cache object could be tricky and one solution could be just get the all the parameters and concatenate those.
return function(){
var args = arguments;  
var key = [].slice.call(args).join('');
if(cache[key]){
  return cache[key];
}
else{
  cache[key] = fn.apply(thi, args);
  return cache[key];
}
}
=======================================================================================================
Animation
Question: How could you implement moveLeft animation?

Use setInterval that will place the element to the left position by some pixels in every 10ms.
you will see the element moving towards the desired position. When you call setInterval, it returns a timeId
After reaching the desired location, you have to clear the time interval so that function will not be called again and again in every 10ms.
function moveLeft(elem, distance) {
var left = 0;

function frame() {
left++;
elem.style.left = left + 'px';

if (left == distance)
  clearInterval(timeId)
}

var timeId = setInterval(frame, 10); // draw every 10ms
}

=======================================================================================================
Currying
Question: How would you implement currying for any functions?
Curring is partial invocation of a function. Currying means first few arguments of a function is pre-processed and a function is returned.
Currying means first few arguments of a function is pre-processed and a function is returned.
The returning function can add more arguments to the curried function.
It's like if you have given one or two spice to the curry and cooked little bit, still you can add further spice to it.
function addBase(base){
return function(num){
return base + num;
}
}

var addTen = addBase(10);
addTen(5); //15
addTen(80); //90
addTen(-5); //5
You are creating a closure that return a function. When you are curring with a new number, new number is added to the base you have provided.
=======================================================================================================
What are differences between host object and native object?
The JavaScript spec groups built-in objects and user objects together as native objects.
native objects
object in an ECMAScript implementation whose semantics are fully defined by this specification rather than by the host environment.
Built-in objects: 
String, Math, RegExp, Object, Function etc. - core predefined objects always available in JavaScript. Defined in the ECMAScript spec.
User objects: 
objects defined in JavaScript code  by the user.
host objects
object supplied by the host environment to complete the execution environment of ECMAScript.
objects like window, XmlHttpRequest, DOM nodes and so on, which is provided by the browser environment. They are distinct from the built-in objects because not all environment will have the same host objects. If JavaScript runs outside of the browser, for example as server side scripting language like in Node.js, different host objects will be available.

=======================================================================================================
How will you get query string in a browsers URL?
var querystring = location.search.replace('?', '').split('&');
for (var i = 0; i < querystring.length; i++) {
var name = querystring[i].split('=')[0];
var value = querystring[i].split('=')[1];
queryObj[name] = value;
}
=======================================================================================================
What is the difference between slice, substr, substring?
slice() extracts a part of a string and returns the extracted part in a new string.
If a parameter is negative, the position is counted from the end of the string.
substring() is similar to slice().
The difference is that substring() cannot accept negative indexes.
substr() is similar to slice().
The difference is that the second parameter specifies the length of the extracted part.
If the first parameter is negative, the position counts from the end of the string.
The second parameter can not be negative, because it defines the length.
=======================================================================================================
A synchronous example
let asyncTest = () => {
console.log('first');
console.log('last');
}
asyncTest();
--------------
An asynchronous example
let asyncTest = () => {
console.log('first');
setTimeout(() => console.log('second'), 2000);
console.log('last');
}
asyncTest();
=======================================================================================================
global scope
Global variable is  accessible (get or set the value of it) from any part of your application.
Global Functions could be accessible from any part of your application.
Local Scope
You can only access one (get or set the value of it)- in the local scope.
In JavaScript local scope is defined by a function. If you declare a variable inside a function,
you can only access it (get or set the value) inside of the function. 
If you try to access it from outside of the function, you will get a reference error.
Local Functions : any function inside another function is called a local function.
You can only execute it inside the outer function.
If you really want to get the inner function,
you have to return the function by creating closure (stay tuned for closure information).
--------------------------
Multiple Scope
Multiple functions:: If you have more than one functions and you execute them,
each one of them will create their own scope. However, every execution scope will be linked to the global scope.
Thats is how you have access to the global scope variable and function from any part of your application.
Nested Scope:: If you execute a function within a function, the inner function will create a scope inside the outer function
the inner scope will have access to the outer function variable, while the outer one will have access to the global variable
Closure:: If you have a function inside a function, this is called closure.
Closure is a powerful feature of JavaScript for encapsulation. Some of your function could be closure
---------------------------
Access a Variable
JavaScript doesn't know right away whether this variable is a global variable, a local variable or a parameter.
First (Local Scope): It checks the local variables. 
	If it is in the local scope, JavaScript will grab it and give it to you.
Second (Parameters): If the variable doesn't exists in the local scope, it will then check the the parameters.
Third (Outer Scopes) If the variable you are asking for doesn't exists in the parameter, 
	JavaScript starts walking outside of the function via the scope chain of the current scope. 
	It does this until it hits the end of the chain. 
	The end of the scope is called the "window" object in JavaScript.
Fourth (Window): If the variable exists in the global scope, 
	it would be a property of the global object "window". JavaScript will grab it and give it to you.
Fifth (Undefined): If the variable doesn't exists in the window object, 
	JavaScript will respond with "undefined". This means the variable you are looking for, doesn't exists.
-----------------------------
Hoisting
JavaScript does the exact same thing to hoist (raise) a variable declaration and a function declaration to the top of a function scope
Those variables and functions can be used from any part of the function without raising no reference Exception.
the variable "b" is declared after the return statement. If you execute the foo function, you will not receive the no reference error. If you dont trust me, copy this code and run it at your console.
function foo(){
  return b;
  var b = 7;  
}

foo(); //undefined
While creating Context of a function, JavaScript execution engine, scan through the whole function and brings the variable declaration to the top of the scope
 Only the variable declaration is hoisted. And the variable gets the default value of unassigned, variable which is "undefined"
  if you have a function declaration, the full function will be hoisted.
  function: Any function declaration will be hoisted at the top.
  variable: Following the function, the variable declaration will be hoisted next. 
  If you have a function expression (set function to a variable), only the variable part will be hoisted.
  The assignment of the function to a variable will stay in its place.
  function myFunc() {    
    var bar = function() {
            return 'world';
        };    
    function foo() {
        return 'fooed';
    }
    var a = 5;
}
he function declaration of the function foo will be hoisted to the top, followed by the variable bar (from function expression) and variable "a". Post-hoisting
function myFunc() {
    function foo() {
        return 'fooed';
    }    
    var bar;
    var a;    
    bar = function() {
            return 'world';
        };
    a = 5;        
}
---------------------------------------
Closure
If you have a function within a function, execution of the inner function will create a scope inside of the outer function- a nested scope
Because the inside function scope is enclosed by the outer function scope, the inner function scope is called a closure
 to be a closure, you dont have to return a function, you just have to call a function inside a function.
 function a(){
  function b(){
     console.log('closure');
  }
  b(); //creates closure
}
---------
function counter(){
    var i = 0;
    
    return function(){
       return i++;
    }
}
var a = counter();
a(); //0
a(); //1
a(); //2
a(); //3
a(); //4
a(); //5
This means, each closure maintains separate private variables of the outer function. This is a very powerful feature of JavaScript
 You would not be able to access (get or set) the value of "i" from outside. Hence the privacy of the value of "i" is maintained secretly. This is called encapsulation in object oriented programming.
 Don't use a closure when you dont need a closure. And don't create too many nested scope.
 Don't hold excessively large private memory. This could cause memory leak
 ---------------------------------
 Scope:: Scope determines the variable access of a function when it is executed. It depends on where and how a function is executed. Scope is unique to each execution.
 Context:: Context depends on how the function is called. The laymen version of context is the value of "this". If you want to learn more, read Execution context and Stack in JavaScript or watch
=======================================================================================================
window vs document
Question: Is there any difference between window and document?
Yes. JavaScript has a global object and everything runs under it. 
window is that global object that holds global variables, global functions, location, history everything is under it. 
Besides, setTimeout, ajax call (XMLHttpRequest), console or localStorage are part of window.
=======================================================================================================
http://www.thatjsdude.com/interview/dom.html
https://github.com/khan4019/front-end-Interview-Questions
=======================================================================================================
Is there any difference between window and document?
Yes. JavaScript has a global object and everything runs under it. window is that global object that holds global variables, global functions, location, history everything is under it. Besides, setTimeout, ajax call (XMLHttpRequest), console or localStorage are part of window.

document is also under window. document is a property of the window object. document represents the DOM and DOM is the object oriented representation of the html markup you have written. All the nodes are part of document. Hence you can use getElementById or addEventListener on document. 

These methods are not present in the window object.
=======================================================================================================
Does document.onload and window.onload fire at the same time?
window.onload is fired when DOM is ready and all the contents including images, css, scripts, sub-frames, etc. finished loaded.
This means everything is loaded.
document.onload is fired when DOM (DOM tree built from markup code within the document)is ready which can be prior to images and other external content is loaded.
document.readyState 
Returns "loading" while the Document is loading, 
"interactive" once it is finished parsing but still loading sub-resources, and 
"complete" once it has loaded. The readystatechange event fires on the Document object when this value changes.
=======================================================================================================
attribute vs property
attributes are just like attribute in your html tag inside the starting tag
html attributes are exposed to the DOM via property.
 a property is created when DOM is parsed for each attribute in the html tag
If you change an attribute only the value of the property will change. the value of attribute will remain same.
=======================================================================================================
What are the different ways to get an element from DOM?
getElementById to get a element that has the provided Id.
getElementsByClassName to get a nodelist (nodelist is not an array, rather it is array-like object) by providing a class name.
getElementsByTagName to get a nodelist by the provided tag name.
querySelector you will pass css style selector (jquery style) and this will retrurn first matched element in the DOM.
querySelectorAll will return a non-live nodelist by using depth-first pre order traversal of all the matched elements. Non-live means, any changes after selecting the elements will not be reflected.
=======================================================================================================
What is the fastest way to select elements by using css selectors?
ID (#myID)
Class (.myClass)
Tag (div, p)
Sibling (div+p, div~p)
child (div>p)
Descendant (div p)
Universal (*)
Attribute (input[type="checkbox"])
Pseudo (p:first-child)
=======================================================================================================
How come, I can't use forEach or similar array methods on a NodeList?
Both are inherited from Object. However array has different prototype object than nodeList. forEach, map, etc are on array.prototype which doesn't exist in the NodeList.prototype object. Hence, you don't have forEach on a nodeList
How could you solve this problem?
you can simply loop through a nodeList and do whatever you wanted to inside forEach or you can call method on array to convert nodelist to an array. 

var myNodeList = document.querySelectorAll('.my-class');
var nodesArray = Array.prototype.slice.call(myNodeList);
//use array method on nodeList
nodesArray.forEach(function(el, idx){
  console.log(idx, el);
})
=======================================================================================================
How would you add a class to an element by query selector?
function addClass(selector, className){
   var elm = document.querySelector(selector);
   if (elm){
      elm.classList.add(className);
   }
}
el.classList.remove('my-class'); //removing a class
el.classList.toggle('my-class');  // toggling a class
el.classList.contains('my-class'); // checking whether class exists
=======================================================================================================
How could I verify whether one element is child of another?
First check whether the passed parent is the direct parent of the child. If not, keep moving upward to the root of the tree.

function isDescendant(parent, child){ 
  while(child.parentNode ){ 
    if(child.parentNode == parent)
      return true;
    else
      child = child.parentNode;
  }
  return false;
}
=======================================================================================================
What is the best way to create a DOM element? Set innherHTML or use createElement?
When you set innerHTML property, browser removes all the current children of the elements. Parse the string and assign the parsed string to the element as children
innerHTML could be slow while parsing a string. Browser has to deal with the string and if you have inner html
while using appendChild, you create a new Element. Since you are creating it, browser doesnt have to parse string and there is no invalid html. And you can pass the child to the parent and child will be appended to the parent. 
=======================================================================================================
What is createDocumentFragment and why you might use it?
documentFragment a very lightweight or minimal part of a DOM or a subtree of a DOM tree
becomes expensive to hit a certain portion of DOM for hundreds time. You might cause reflow for hundred times

//bad practice. you are hitting the DOM every single time
var list = ['foo', 'bar', 'baz', ... ],
    el, text;
for (var i = 0; i < list.length; i++) {
    el = document.createElement('li');
    text = document.createTextNode(list[i]);
    el.appendChild(text);
    document.body.appendChild(el);
}

//good practice. you causing reflow one time
var fragment = document.createDocumentFragment(),
    list = ['foo', 'bar', 'baz', ...],
    el, text;
for (var i = 0; i < list.length; i++) {
    el = document.createElement('li');
    text = document.createTextNode(list[i]);
    el.appendChild(text);
    fragment.appendChild(el);
}
document.body.appendChild(fragment);
  
=======================================================================================================
What is reflow? What causes reflow? How could you reduce reflow?
When you change size or position of an element in the page, all the elements after it has to change their position according to the changes you made.
 For example, if you change height on an element, all the elements under it has to move down in the page to accomodate a change in height.
 Hence, flow of the elements in the page is changed and this is called reflow.
 Reflows could be very expensive and it might have a performance hit specially in the smaller devices like phone. As it might causes changes in the portion (or whole) layout of the page.
	change layout (geometry of the page)
	resize the window
	change height/width of any element
	changing font
	change font size
	move DOM element (animation)
	adding or removing stylesheet
	calculating offset height or offset width
	display: none;
=======================================================================================================
What is repaint and when does this happen?
repaint happens when you change the look of an element without changing the size and shape. This doesn't cause reflow as geometry of the element didn't changed.
=======================================================================================================
How could you make sure to run some javaScript when DOM is ready like $(document).ready?
There are four different ways-

option-1: Put your script in the last tag of html body element. DOM would be ready by the time browser hits the script tag.

option-2: Place your code inside a DOMContentLoaded handler. This event will be fired when DOM is completely loaded.
document.addEventListener('DOMContentLoaded', function(){   
   //put your script here
});

option-3: Watch changes in the readyState of the document. And the last state is "complete" state, you can put your code there.
document.onreadystatechange = function () {  
  if (document.readyState == "complete") {
    //put your script here
  }
}
option-4: Search jquery source code and copy dom ready function. In that case you have a ready function that works in the older browsers as well without loading the whole jquery library.
=======================================================================================================
What is event bubble? How does event flows?
If you have a table with multiple rows and multiple columns and you click in one of the cell
You will think that you have clicked on the cell and browser will know that you have a click handler with the cell that will be fired immediately.
You are completely wrong. Right away, browser doesn't know where you have clicked.

Capture: When you clicked, browser knows a click event occurred. It starts from the window (lowest level/root of your website), then goes to document, then html root tag, then body, then table... its trying to reach the the as lowest level of element as possible. This is called capture phase (phase -1).
Target: When browser reach the lowest level of element. In this case, you have clicked on a table cell (table data) hence target would be "td" tag. Then browser checks whether you have any click handler attached to this element. If there is any, browser executes that click hander. This is called target phase (phase -2).
Bubbling: After firing click hander attached to "td", browser walks toward root. One level upward and check whether there is any click handler attached with table row ("tr" element). If there is any it will execute that. Then it goes to tbody, table, body, html, document, window. In this stage its moving upward and this is called event bubbling or bubbling phase (phase-3). Please note that, you clicked on cell but all the event handler with parent elements will be fired. This is actually very powerful (check event delegation)

=======================================================================================================
Event Delegate
How would you destroy multiple list items with one click handler?
We can actually leverage event bubbling. You can have only one event handler attached to the parent element of one hundred list items. In this case, you can attach the event handler to the "ul" tag. After you click on a list item (list item does not have an event), event will bubble and "ul" has a handler. That handler will be fired.
document.getElementById('listToDestroy').addEventListener('click', function (e) { 
    var elm = e.target.parentNode; 
        elm.parentNode.removeChild(elm);
        e.preventDefault();
});
=======================================================================================================
Create a button that is destroyed by clicking on it but two new buttons are created in it's place.
One way of solving is to attach a event handler with the button to destroy itself and append two
we can leverage event delegate. If we attach the event hander to the parent div instead of the button itself. We don't have to add the event handler to each button we create. So, we will take advantage of event bubbling.
Make sure when you are destroying, there is no reference to the element, otherwise, you will have memory leak. If interviewer, says ok, just create one more button on click, then use your brain to change the following code.
document.getElementById('doubleHolder').addEventListener('click', function (e) {   
   if(e.target.classList.contains('double')){
      var btn = document.createElement('button');
      btn.setAttribute('class', 'double');
      btn.innerHTML = 'double';

      var btn2 = document.createElement('button');
      btn2.setAttribute('class', 'double');
      btn2.innerHTML = 'double';
     
      this.appendChild(btn);
      this.appendChild(btn2);
      this.removeChild(e.target);   
    }
  }); 
=======================================================================================================
How could you capture all clicks in a page?
You can leverage, event bubble to capture all the clicks. As all the clicks will be bubbled up to the body.
ocument.querySelector('body').addEventListener('click', function(e){
  console.log('body clicked', e.target);
});

//or
window.onclick =function(e){
  console.log('someone clicked', e.target)
}
=======================================================================================================
How can you get all the texts in a web page?
The easiest way to get all the text is to get the innerText of body tag.
document.body.innerText;

Can you do by accessing DOM?
Make it recursive. I used closure. There could be many other ways to implement.
function getAllText(node){
  var allText = [];

  function getNodeText(node){
      if(node && node.childNodes && node.childNodes.length){
          for(var i = 0, len = node.childNodes.length; i<len; i++){
              getNodeText(node.childNodes[i]);
          }
      }
      else{
          allText.push(node.nodeValue);
     }
  }
  getNodeText(node);
  return allText.join('');
}
=======================================================================================================
What is defer and async keyword does in a script tag?
HTML parser will ignore defer and async keyword for inline script ( script that does not have a src attribute).
When you have a plain script tag (no defer or async keyword), parser will pause parsing, script would be downloaded and exectuted. After that parsing resume.
defer keyword in the script tag will defer the execution of the script. Hence script will be executed when DOM is available. 

async: If possible, set the execution of the script, asynchronously. async keyword has no effect on inline script.defer is not supported by all major major browsers.
Synchronous scripts are bad because they force the browser to block DOM construction, fetch the script, and execute it before the browser can continue processing the rest of the page
=======================================================================================================
Question: How could you prevent a click on an anchor from going to the link?
Answer: preventDefault() inside event handler. However, this doesnt stop further propagation.

Question: How could you stop further propagation of an event?
Answer: Call event.stopPropagation();

Question: Can you remove an event handler from an element?
Answer: Yes. target.removeEventListener('click', handler)

Question: How could you run event handler in the capturing phase not in bubble phase?
Answer: There is a third (optional) parameter in addEventListener and removeEventLister. You can pass true or false to useCapture phase.

Question: How could you prevent multiple event handler to be fired for an event?
Answer: If event listeners are attached for the same type event (click, keydown, etc.) of an element for the same event type, you can call event.stopImmediatePropagation() in the first event handler. No other event handler will be executed.

Question: What are the cancelable events?
Answer: Go to wiki find the right most column cancelable.

Question: How could I check whether an event is cancelable or not?
Answer: Use event.cancelable to get true or false return. However, you have to preventDefault() to prevent the event.

Question: Is there anything you have to be careful when using node.cloneNode()?
Answer: While cloning, make sure you didnt duplicate ID.

Question: What are different nodeTypes?
Answer: ELEMENT_NODE (1), TEXT_NODE (3), COMMENT_NODE(8), DOCUMENT_NODE(9), DOCUMENT_TYPE_NODE(10), DOCUMENT_FRAGMENT_NODE(11), etc.

A node is the generic name for any type of object in the DOM hierarchy. A node could be one of the built-in DOM elements such as document or document.body, it could be an HTML tag specified in the HTML such as <input> or <p> or it could be a text node that is created by the system to hold a block of text inside another element. So, in a nutshell, a node is any DOM object.

Question: What are the differences between node and element?
Answer: An element is one specific type of node as there are many other types of nodes (text nodes, comment nodes, document nodes, etc...).
